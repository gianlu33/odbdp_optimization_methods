	/*
	 * local search method. Best improvement
	 * change the value of one index (activated -> not activated and viceversa)
	 * until convergence is reached
	 */

	private void bestImprovement(Solution child) {
		int nIndexes = data.getnIndexes();
		int bestObjectiveFunction = child.getObjectiveFunction();
		int tempObjectiveFunction;
		boolean[] indexes;
		Solution tempSolution, bestSolution = null;
		boolean found;
		//float tempFitness;
		//float bestFitness = child.getFitness();

		while(true) {
			indexes = child.getIndexes();
			found = false;
			
			for(int i=0; i<nIndexes; i++) {
				indexes[i] = !indexes[i];
				
				tempSolution = Utils.generateSolutionFromIndexes(data, indexes);
				tempObjectiveFunction = tempSolution.getObjectiveFunction();
				//tempFitness = tempSolution.getFitness();
				
				checkAndSaveBestSolution(tempSolution);
				
				//if(tempSolution.isFeasible() && tempObjectiveFunction > bestObjectiveFunction) {
				if(tempObjectiveFunction > bestObjectiveFunction) {
				//if(tempFitness > bestFitness) {
					bestObjectiveFunction = tempObjectiveFunction;
					//bestFitness = tempFitness;
					bestSolution = tempSolution;
					found = true;
				}
				
				indexes[i] = !indexes[i]; //restore state
			}
			
			if(!found) return; //actual solution is already the best
			
			child.setObjectiveFunction(bestSolution.getObjectiveFunction());
			child.setMemory(bestSolution.getMemory());
			child.setIndexes(bestSolution.getIndexes());
			child.setMatrix(bestSolution.getMatrix());
			child.setFeasible(bestSolution.isFeasible());
			child.setFitness(bestSolution.getFitness());
		}
	}